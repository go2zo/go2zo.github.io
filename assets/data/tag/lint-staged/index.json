{"hash":"12c81b4eaf125a746d2dbc36b277a349e8c9fed6","data":{"tag":{"title":"lint-staged","belongsTo":{"edges":[{"node":{"title":"Lint-staged와 Husky를 이용해 자동화 하기","path":"/lint-staged-and-husky/","date":"14. November 2020","timeToRead":3,"description":"lint-staged와 husky를 이용해 eslint와 커밋 메시지에 issue 번호 지정을 자동화 한다.","content":"<h1 id=\"husky란\"><a href=\"#husky%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><a href=\"https://typicode.github.io/husky/#/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Husky</a>란?</h1>\n<p>Husky는 node 환경에서 git hook 제어를 용이하게 해 주는 툴이다. 기본적으로 git hook은 로컬저장소의 <code>.git/hooks</code> 디렉토리에 위치해 있다. 그리고 이 디렉토리는 git 버전관리의 대상이 아니다. husky는 hook을 공유 가능하도록 해준다.</p>\n<p>husky를 설치하면 모든 git hook은 husky를 실행하도록 설정된다. 실제로 husky를 설치하고 <code>.git/hook</code> 디렉토리를 확인하면 모든 hook 파일들이 활성화(.sample이 붙어있지 않은 파일들) 되어 있는 것을 볼 수 있다. husky에 의해 생성된 파일들은 수동으로 변경하지 않아야 한다(<del>고 알고 있다</del>). 어차피 변경을 해도 변경사항은 공유되지 않을 것이다.</p>\n<p><img src=\"images/image-20201113161622506.png\" alt=\"image-20201113161622506\"></p>\n<h1 id=\"lint-staged--husky-설치\"><a href=\"#lint-staged--husky-%EC%84%A4%EC%B9%98\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Lint-staged &#x26; Husky 설치</h1>\n<p><a href=\"https://mrm.js.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mrm</a>은 오픈소스 프로젝트의 환경 설정을 동기화 하기 위한 도구이다. lint-staged도 지원하고 있으며 공식문서에도 아래와 같이 설치하도록 안내하고 있다.</p>\n<pre><code class=\"language-bash\">$ npx mrm lint-staged\n</code></pre>\n<p>어떻게 설치되는지 보려고 package.json에서 lint-staged관련 설정들을 모두 지우고 실행해 봤다. 아래와 같이 <code>pre-commit</code> 시 <code>lint-staged</code>가 실행되도록 설정된 것을 볼 수 있다.</p>\n<pre><code class=\"language-json\">// package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"*.{js,vue}\": \"eslint --cache --fix\"\n  }\n}\n</code></pre>\n<h1 id=\"commit-message에-issue-number-자동-삽입\"><a href=\"#commit-message%EC%97%90-issue-number-%EC%9E%90%EB%8F%99-%EC%82%BD%EC%9E%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Commit message에 Issue Number 자동 삽입</h1>\n<p>husky를 이용해 npm script만 사용 가능한 것은 아니다.</p>\n<p>쉘 스크립트도 실행 가능하고 복잡한 스크립트는 파일로 따로 작성하여 호출할 수 있다.</p>\n<pre><code class=\"language-json\">// package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged &#x26;&#x26; your-custom-script.sh\"\n    }\n  }\n}\n</code></pre>\n<p>이를 이용해 commit message에 issue 번호를 삽입하는 기능을 추가해 보려 한다.</p>\n<p>해당 기능은 commit message를 준비하는 과정으로 <code>prepare-commit-msg</code> 훅에 속한다.</p>\n<pre><code class=\"language-json\">// package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\",\n      \"prepare-commit-msg\": \"./scripts/add_issue_number_into_commit.sh $HUSKY_GIT_PARAMS\"\n    }\n  }\n}\n</code></pre>\n<p>실제 동작하는 스크립트는 아래와 같이 작성되었다. (<a href=\"https://www.huskyhoochu.com/npm-husky-the-git-hook-manager/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">husky님의 블로그 글</a>을 대부분 참조했다.)</p>\n<pre><code class=\"language-sh\">#!/usr/bin/env bash\n\nCOMMIT_MSG_FILE=$1\n\nbranch_name=`git rev-parse --abbrev-ref HEAD`\ncut_number=`echo ${branch_name} | cut -d '-' -f1`\nfirst_line=`head -n1 ${COMMIT_MSG_FILE}`\n\n# if commit_msg_file's first line is empty,\n# add branch name in commit_msg\nif [ -z \"$first_line\" ]; then\n    sed -i \".bak\" \"1s/^/[#$cut_number] /\" $1\nfi\n</code></pre>\n<p>스크립트 실행 시 <code>HUSKY_GIT_PARAMS</code>로 git 파라미터를 bypass로 전달한다.</p>\n<table>\n<thead>\n<tr>\n<th>Index</th>\n<th>Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$1</td>\n<td>COMMIT_MSG_FILE</td>\n<td>이 변수가 가리키는 <code>.git/COMMIT_EDITMSG</code> 파일은 커밋 시 출력되는 메시지를 담고 있다.</td>\n</tr>\n<tr>\n<td>$2</td>\n<td>COMMIT_SOURCE</td>\n<td>merge, message, template, commit 등 커밋의 종류를 나타낸다.</td>\n</tr>\n<tr>\n<td>$3</td>\n<td>SHA</td>\n<td>최근 커밋 수정(commit -amend)의 경우에는 커밋 hash 값을 추가로 받는다.</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"references\"><a href=\"#references\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>References</h1>\n<ul>\n<li><a href=\"https://www.huskyhoochu.com/npm-husky-the-git-hook-manager/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.huskyhoochu.com/npm-husky-the-git-hook-manager/</a></li>\n</ul>\n"}},{"node":{"title":"Lint-staged를 이용해 Eslint 자동화하기","path":"/use-the-lint-staged-to-automatic-eslint/","date":"13. November 2020","timeToRead":4,"description":"lint-staged에 대해 알아본다.","content":"<h1 id=\"반복적인-번거로운-lint\"><a href=\"#%EB%B0%98%EB%B3%B5%EC%A0%81%EC%9D%B8-%EB%B2%88%EA%B1%B0%EB%A1%9C%EC%9A%B4-lint\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>반복적인, 번거로운 lint</h1>\n<p>필자는 지식이 얕아 lint를 코딩 룰 체크용도만 주로 사용한다. 항상 코딩 단계에서 콤마나 세미콜론을 챙길 수 없기에 주기적, 혹은 커밋 직전에 <code>eslint --fix</code>를 이용해 일괄 수정한다.</p>\n<p>하지만 lint를 매번 일일이 실행하기도 번거롭고 특히 깜빡하고 실행하지 않고 커밋하는 경우도 종종 발생하게 된다. 협업을 할 때도 원격 저장소를 pull하면 단순히 다른 개발자와 indent 설정이 tab이냐 space냐에 따라 충돌이 일어나기도 한다.(이것은 lint 말고도 <a href=\"https://editorconfig.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>.editorconfig</code></a>로도 처리가 가능하긴 하다.) 비단 팀 프로젝트 뿐 아니라 1인 프로젝트라고 이런 일이 발생하지 않는 것은 아니다. 어느 지나가는 블로그 글에서 봤는데 <strong>1인 프로젝트에서의 맴버는 미래의 나</strong>라는 말이 참으로 와 닿았다. 커밋 전에 linting을 하지 않으면 미래의 내가 지금 나한테 욕을 할지도 모른다.</p>\n<p><code>git hook</code>은 존재만 알고 있고 <code>lint-staged</code>는 뭔지 알지도 못하던 와중에 현재 블로그를 만들며 참조한 스타터에 해당 패키지가 설정되어 있었다. 하지만 왠지 설정에 뭔가 누락된 듯하고 실제로 동작도 하지 않고 있었다. 왜일까? <code>package.json</code>에 설정된 <code>gitHooks</code> 항목이 있는데 dependencies에도 추가적인 것이 없고 어떤 라이브러리인지 도통 알 수 없었다.</p>\n<pre><code class=\"language-json\">// package.json\n{\n  \"gitHooks\": {\n    \"pre-commit\": \"lint-staged\"\n  }\n}\n</code></pre>\n<h1 id=\"git-hook-이란\"><a href=\"#git-hook-%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><a href=\"https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-Hooks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Git Hook</a> 이란?</h1>\n<p>git은 commit이나 rebase, merge, push 등의 이벤트가 발생할 때 훅을 이용해 특정 스크립트를 실행할 수 있도록 지원한다. 이벤트마다 <code>pre-</code>, <code>post-</code>로 시작하는 훅들이 대부분 존재하며 의미대로 이벤트 전, 후에 실행된다. 아래 이야기 할 <code>lint-staged</code>는 커밋 전에 실행되는 <code>pre-commit</code> 훅을 이용한다. lint를 이용한 코드 검사 외에도 새로 추가한 코드에 주석을 달았는지 여부 등을 검사하여 커밋된 소스들의 일관성을 유지할 수 있다.</p>\n<h1 id=\"lint-staged-설정\"><a href=\"#lint-staged-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>lint-staged 설정</h1>\n<p><a href=\"https://www.npmjs.com/package/lint-staged\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>lint-staged</code></a>는 이름에서도 보이듯이 stage 상의 git 파일들에 대해 lint를 실행한다. 실질적으로는 lint 만을 실행한다기 보다 설정한 명령을 실행한다는게 맞을 것이다. stage 상태란 것은 쉽게 말해 <code>git add</code>로 커밋 대상이 된 파일들이다.</p>\n<p>실행을 위해 <code>package.json</code>에 아래와 같이 작성한다. (<code>.lintstagedrc</code>파일을 이용할 수도 있다.)</p>\n<pre><code class=\"language-json\">// package.json\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  }\n  \"lint-staged\": {\n    \"*.{js,vue}\": [\n      \"yarn lint\",\n      \"git add\"\n    ]\n  },\n}\n</code></pre>\n<p>위 <code>pre-commit</code> 훅 호출방식은 현재 <code>deprecated</code> 상태이다. 그럼에도 아직 아래와 같이 실행이 가능하긴 하다. 아래는 vue 파일을 수정하고 커밋을 실행 화면이다.</p>\n<p><img src=\"images/image-20201113114525996.png\" alt=\"image-20201113114525996\"></p>\n<h1 id=\"나머지는-다음-포스트로\"><a href=\"#%EB%82%98%EB%A8%B8%EC%A7%80%EB%8A%94-%EB%8B%A4%EC%9D%8C-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%A1%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>나머지는 다음 포스트로</h1>\n<p>위 실행화면과 문서에도 나와있듯이 <code>lint-staged</code>를 제대로 사용하기 위해서는 <code>husky</code>가 필요하다. 대부분의 타 포스트들에는 <code>lint-staged</code>와 <code>husky</code>를 함께 설명하고 있다. <code>husky</code>를 이용해 lint를 자동화 하는 것과 커밋 메시지를 컨트롤 하는 부분에 대해서는 다음 포스트에 진행한다.</p>\n"}}]}}},"context":{}}