<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Lint-staged를 이용해 Eslint 자동화하기 - Go2zo</title><meta name="gridsome:hash" content="12c81b4eaf125a746d2dbc36b277a349e8c9fed6"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Simple is the best."><meta data-vue-tag="ssr" name="description" content="lint-staged에 대해 알아본다."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/6.styles.86464a36.css" as="style"><link rel="preload" href="/assets/js/app.99a19a4e.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.6ebe960c.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.e63af27c.js"><link rel="prefetch" href="/assets/js/page--src--pages--about-vue.4bb37809.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.50021861.js"><link rel="prefetch" href="/assets/js/page--src--templates--tag-vue.b8e2eadf.js"><link rel="stylesheet" href="/assets/css/6.styles.86464a36.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><nav role="navigation" aria-label="primary navigation" class="navbar"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item is-size-4 has-text-weight-bold active">
  Go2zo
</a><a role="button" aria-label="menu" aria-expanded="false" class="navbar-burger burger"><span aria-hidden="true"></span><span aria-hidden="true"></span><span aria-hidden="true"></span></a></div><div class="navbar-menu"><div class="navbar-end"><a href="/about" class="navbar-item">
            About
          </a><a href="//github.com/calebanthony/gridsome-bulma" class="navbar-item">
            GitHub
          </a></div></div></div></nav><main class="section"><div class="has-text-centered"><h1 class="title is-1">
      Lint-staged를 이용해 Eslint 자동화하기
    </h1><div class="content subtitle is-size-6">
  Posted 13. November 2020.
  <strong>4 min read.</strong></div></div><div class="post content section container"><!----><p><h1 id="반복적인-번거로운-lint"><a href="#%EB%B0%98%EB%B3%B5%EC%A0%81%EC%9D%B8-%EB%B2%88%EA%B1%B0%EB%A1%9C%EC%9A%B4-lint" aria-hidden="true"><span class="icon icon-link"></span></a>반복적인, 번거로운 lint</h1>
<p>필자는 지식이 얕아 lint를 코딩 룰 체크용도만 주로 사용한다. 항상 코딩 단계에서 콤마나 세미콜론을 챙길 수 없기에 주기적, 혹은 커밋 직전에 <code>eslint --fix</code>를 이용해 일괄 수정한다.</p>
<p>하지만 lint를 매번 일일이 실행하기도 번거롭고 특히 깜빡하고 실행하지 않고 커밋하는 경우도 종종 발생하게 된다. 협업을 할 때도 원격 저장소를 pull하면 단순히 다른 개발자와 indent 설정이 tab이냐 space냐에 따라 충돌이 일어나기도 한다.(이것은 lint 말고도 <a href="https://editorconfig.org/" target="_blank" rel="nofollow noopener noreferrer"><code>.editorconfig</code></a>로도 처리가 가능하긴 하다.) 비단 팀 프로젝트 뿐 아니라 1인 프로젝트라고 이런 일이 발생하지 않는 것은 아니다. 어느 지나가는 블로그 글에서 봤는데 <strong>1인 프로젝트에서의 맴버는 미래의 나</strong>라는 말이 참으로 와 닿았다. 커밋 전에 linting을 하지 않으면 미래의 내가 지금 나한테 욕을 할지도 모른다.</p>
<p><code>git hook</code>은 존재만 알고 있고 <code>lint-staged</code>는 뭔지 알지도 못하던 와중에 현재 블로그를 만들며 참조한 스타터에 해당 패키지가 설정되어 있었다. 하지만 왠지 설정에 뭔가 누락된 듯하고 실제로 동작도 하지 않고 있었다. 왜일까? <code>package.json</code>에 설정된 <code>gitHooks</code> 항목이 있는데 dependencies에도 추가적인 것이 없고 어떤 라이브러리인지 도통 알 수 없었다.</p>
<pre><code class="language-json">// package.json
{
  "gitHooks": {
    "pre-commit": "lint-staged"
  }
}
</code></pre>
<h1 id="git-hook-이란"><a href="#git-hook-%EC%9D%B4%EB%9E%80" aria-hidden="true"><span class="icon icon-link"></span></a><a href="https://git-scm.com/book/ko/v2/Git%EB%A7%9E%EC%B6%A4-Git-Hooks" target="_blank" rel="nofollow noopener noreferrer">Git Hook</a> 이란?</h1>
<p>git은 commit이나 rebase, merge, push 등의 이벤트가 발생할 때 훅을 이용해 특정 스크립트를 실행할 수 있도록 지원한다. 이벤트마다 <code>pre-</code>, <code>post-</code>로 시작하는 훅들이 대부분 존재하며 의미대로 이벤트 전, 후에 실행된다. 아래 이야기 할 <code>lint-staged</code>는 커밋 전에 실행되는 <code>pre-commit</code> 훅을 이용한다. lint를 이용한 코드 검사 외에도 새로 추가한 코드에 주석을 달았는지 여부 등을 검사하여 커밋된 소스들의 일관성을 유지할 수 있다.</p>
<h1 id="lint-staged-설정"><a href="#lint-staged-%EC%84%A4%EC%A0%95" aria-hidden="true"><span class="icon icon-link"></span></a>lint-staged 설정</h1>
<p><a href="https://www.npmjs.com/package/lint-staged" target="_blank" rel="nofollow noopener noreferrer"><code>lint-staged</code></a>는 이름에서도 보이듯이 stage 상의 git 파일들에 대해 lint를 실행한다. 실질적으로는 lint 만을 실행한다기 보다 설정한 명령을 실행한다는게 맞을 것이다. stage 상태란 것은 쉽게 말해 <code>git add</code>로 커밋 대상이 된 파일들이다.</p>
<p>실행을 위해 <code>package.json</code>에 아래와 같이 작성한다. (<code>.lintstagedrc</code>파일을 이용할 수도 있다.)</p>
<pre><code class="language-json">// package.json
{
  "scripts": {
    "precommit": "lint-staged"
  }
  "lint-staged": {
    "*.{js,vue}": [
      "yarn lint",
      "git add"
    ]
  },
}
</code></pre>
<p>위 <code>pre-commit</code> 훅 호출방식은 현재 <code>deprecated</code> 상태이다. 그럼에도 아직 아래와 같이 실행이 가능하긴 하다. 아래는 vue 파일을 수정하고 커밋을 실행 화면이다.</p>
<p><img src="images/image-20201113114525996.png" alt="image-20201113114525996"></p>
<h1 id="나머지는-다음-포스트로"><a href="#%EB%82%98%EB%A8%B8%EC%A7%80%EB%8A%94-%EB%8B%A4%EC%9D%8C-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%A1%9C" aria-hidden="true"><span class="icon icon-link"></span></a>나머지는 다음 포스트로</h1>
<p>위 실행화면과 문서에도 나와있듯이 <code>lint-staged</code>를 제대로 사용하기 위해서는 <code>husky</code>가 필요하다. 대부분의 타 포스트들에는 <code>lint-staged</code>와 <code>husky</code>를 함께 설명하고 있다. <code>husky</code>를 이용해 lint를 자동화 하는 것과 커밋 메시지를 컨트롤 하는 부분에 대해서는 다음 포스트에 진행한다.</p>
</p><footer><div class="tags"><a href="/tag/lint-staged/" class="tag">
    #lint-staged
  </a><a href="/tag/eslint/" class="tag">
    #eslint
  </a></div></footer></div><div class="post-comments"></div></main><footer class="footer has-text-centered"><span>Copyright © 2021. </span><span>Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Lint-staged를 이용해 Eslint 자동화하기","path":"\u002Fuse-the-lint-staged-to-automatic-eslint\u002F","date":"13. November 2020","timeToRead":4,"tags":[{"id":"lint-staged","title":"lint-staged","path":"\u002Ftag\u002Flint-staged\u002F"},{"id":"eslint","title":"eslint","path":"\u002Ftag\u002Feslint\u002F"}],"description":"lint-staged에 대해 알아본다.","content":"\u003Ch1 id=\"반복적인-번거로운-lint\"\u003E\u003Ca href=\"#%EB%B0%98%EB%B3%B5%EC%A0%81%EC%9D%B8-%EB%B2%88%EA%B1%B0%EB%A1%9C%EC%9A%B4-lint\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E반복적인, 번거로운 lint\u003C\u002Fh1\u003E\n\u003Cp\u003E필자는 지식이 얕아 lint를 코딩 룰 체크용도만 주로 사용한다. 항상 코딩 단계에서 콤마나 세미콜론을 챙길 수 없기에 주기적, 혹은 커밋 직전에 \u003Ccode\u003Eeslint --fix\u003C\u002Fcode\u003E를 이용해 일괄 수정한다.\u003C\u002Fp\u003E\n\u003Cp\u003E하지만 lint를 매번 일일이 실행하기도 번거롭고 특히 깜빡하고 실행하지 않고 커밋하는 경우도 종종 발생하게 된다. 협업을 할 때도 원격 저장소를 pull하면 단순히 다른 개발자와 indent 설정이 tab이냐 space냐에 따라 충돌이 일어나기도 한다.(이것은 lint 말고도 \u003Ca href=\"https:\u002F\u002Feditorconfig.org\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E\u003Ccode\u003E.editorconfig\u003C\u002Fcode\u003E\u003C\u002Fa\u003E로도 처리가 가능하긴 하다.) 비단 팀 프로젝트 뿐 아니라 1인 프로젝트라고 이런 일이 발생하지 않는 것은 아니다. 어느 지나가는 블로그 글에서 봤는데 \u003Cstrong\u003E1인 프로젝트에서의 맴버는 미래의 나\u003C\u002Fstrong\u003E라는 말이 참으로 와 닿았다. 커밋 전에 linting을 하지 않으면 미래의 내가 지금 나한테 욕을 할지도 모른다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Egit hook\u003C\u002Fcode\u003E은 존재만 알고 있고 \u003Ccode\u003Elint-staged\u003C\u002Fcode\u003E는 뭔지 알지도 못하던 와중에 현재 블로그를 만들며 참조한 스타터에 해당 패키지가 설정되어 있었다. 하지만 왠지 설정에 뭔가 누락된 듯하고 실제로 동작도 하지 않고 있었다. 왜일까? \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E에 설정된 \u003Ccode\u003EgitHooks\u003C\u002Fcode\u003E 항목이 있는데 dependencies에도 추가적인 것이 없고 어떤 라이브러리인지 도통 알 수 없었다.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E\u002F\u002F package.json\n{\n  \"gitHooks\": {\n    \"pre-commit\": \"lint-staged\"\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch1 id=\"git-hook-이란\"\u003E\u003Ca href=\"#git-hook-%EC%9D%B4%EB%9E%80\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fgit-scm.com\u002Fbook\u002Fko\u002Fv2\u002FGit%EB%A7%9E%EC%B6%A4-Git-Hooks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EGit Hook\u003C\u002Fa\u003E 이란?\u003C\u002Fh1\u003E\n\u003Cp\u003Egit은 commit이나 rebase, merge, push 등의 이벤트가 발생할 때 훅을 이용해 특정 스크립트를 실행할 수 있도록 지원한다. 이벤트마다 \u003Ccode\u003Epre-\u003C\u002Fcode\u003E, \u003Ccode\u003Epost-\u003C\u002Fcode\u003E로 시작하는 훅들이 대부분 존재하며 의미대로 이벤트 전, 후에 실행된다. 아래 이야기 할 \u003Ccode\u003Elint-staged\u003C\u002Fcode\u003E는 커밋 전에 실행되는 \u003Ccode\u003Epre-commit\u003C\u002Fcode\u003E 훅을 이용한다. lint를 이용한 코드 검사 외에도 새로 추가한 코드에 주석을 달았는지 여부 등을 검사하여 커밋된 소스들의 일관성을 유지할 수 있다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"lint-staged-설정\"\u003E\u003Ca href=\"#lint-staged-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003Elint-staged 설정\u003C\u002Fh1\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Flint-staged\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E\u003Ccode\u003Elint-staged\u003C\u002Fcode\u003E\u003C\u002Fa\u003E는 이름에서도 보이듯이 stage 상의 git 파일들에 대해 lint를 실행한다. 실질적으로는 lint 만을 실행한다기 보다 설정한 명령을 실행한다는게 맞을 것이다. stage 상태란 것은 쉽게 말해 \u003Ccode\u003Egit add\u003C\u002Fcode\u003E로 커밋 대상이 된 파일들이다.\u003C\u002Fp\u003E\n\u003Cp\u003E실행을 위해 \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E에 아래와 같이 작성한다. (\u003Ccode\u003E.lintstagedrc\u003C\u002Fcode\u003E파일을 이용할 수도 있다.)\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E\u002F\u002F package.json\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  }\n  \"lint-staged\": {\n    \"*.{js,vue}\": [\n      \"yarn lint\",\n      \"git add\"\n    ]\n  },\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E위 \u003Ccode\u003Epre-commit\u003C\u002Fcode\u003E 훅 호출방식은 현재 \u003Ccode\u003Edeprecated\u003C\u002Fcode\u003E 상태이다. 그럼에도 아직 아래와 같이 실행이 가능하긴 하다. 아래는 vue 파일을 수정하고 커밋을 실행 화면이다.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"images\u002Fimage-20201113114525996.png\" alt=\"image-20201113114525996\"\u003E\u003C\u002Fp\u003E\n\u003Ch1 id=\"나머지는-다음-포스트로\"\u003E\u003Ca href=\"#%EB%82%98%EB%A8%B8%EC%A7%80%EB%8A%94-%EB%8B%A4%EC%9D%8C-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%A1%9C\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E나머지는 다음 포스트로\u003C\u002Fh1\u003E\n\u003Cp\u003E위 실행화면과 문서에도 나와있듯이 \u003Ccode\u003Elint-staged\u003C\u002Fcode\u003E를 제대로 사용하기 위해서는 \u003Ccode\u003Ehusky\u003C\u002Fcode\u003E가 필요하다. 대부분의 타 포스트들에는 \u003Ccode\u003Elint-staged\u003C\u002Fcode\u003E와 \u003Ccode\u003Ehusky\u003C\u002Fcode\u003E를 함께 설명하고 있다. \u003Ccode\u003Ehusky\u003C\u002Fcode\u003E를 이용해 lint를 자동화 하는 것과 커밋 메시지를 컨트롤 하는 부분에 대해서는 다음 포스트에 진행한다.\u003C\u002Fp\u003E\n","cover_image":null}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.99a19a4e.js" defer></script><script src="/assets/js/page--src--templates--post-vue.6ebe960c.js" defer></script>
  </body>
</html>